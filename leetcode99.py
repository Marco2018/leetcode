# Definition for a binary tree node.class TreeNode:     def __init__(self, x):         self.val = x         self.left = None         self.right = Noneclass Solution:    def recoverTree(self, root):        """        :type root: TreeNode        :rtype: void Do not return anything, modify root in-place instead.        """        def getnums(root):            if root==None:                return            if root.left:                getnums(root.left)            self.nums.append(root.val)            if root.right:                getnums(root.right)            return        def label(root,a,b):            if root==None:                return            if root.val==a:                root.val=self.index1            if root.val == b:                root.val = self.index2            if root.left:                label(root.left,a,b)            if root.right:                label(root.right,a,b)            return        def recover(root,a,b):            if root==None:                return            if root.val==self.index1:                root.val= b            if root.val == self.index2:                root.val = a            if root.left:                recover(root.left,a,b)            if root.right:                recover(root.right,a,b)            return        self.nums,index,a,b=[],[],0,0        getnums(root)        nums2=self.nums.copy()        nums2.sort()        for i in range(len(self.nums)):            if nums2[i]!=self.nums[i]:                index.append(i)        a,b=self.nums[index[0]],self.nums[index[1]]        self.index1,self.index2=max(nums2)+1,max(nums2)+2        label(root, a, b)        recover(root,a,b)        returns=Solution()root=TreeNode(3)root.left=TreeNode(1)root.right=TreeNode(4)root.right.left=TreeNode(2)print(s.recoverTree(root))# 直接改不太好改 容易把其中一个改回去 不好判断因此先将a,b 用index1 index2进行标记