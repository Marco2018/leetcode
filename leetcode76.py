class Solution(object):    def minWindow(self, s, t):        n=len(s)        num=len(t)        start,end,dict=0,0,{}        temp_min_length=float("inf")        temp_i,temp_j=0,0        for item in t:            if item not in dict:                dict[item]=1            else:                dict[item]+=1        for end in range(n):            if s[end] not in dict:                continue            if dict[s[end]]>0:                num-=1            dict[s[end]]-=1            while num==0:                if temp_min_length>end-start+1:                    temp_min_length = end - start + 1                    temp_i=start                    temp_j=end                if s[start] in dict:                    if dict[s[start]]==0:                        num+=1                    dict[s[start]]+=1                start+=1        if temp_min_length!=float("inf"):            return s[temp_i:temp_j+1]        return ""s=Solution()S = "aa"T = "aa"print(s.minWindow(S,T))"""import heapqfrom collections import dequefrom collections import defaultdictclass Solution(object):    def minWindow(self, s, t):        n=len(s)        heap1=[]        dict=defaultdict(deque)        count=1        for item in t:            dict[item].append(count*2*n)            heapq.heappush(heap1,count*2*n)            count+=1        temp_min_length=2*n        temp_i,temp_j=-1,-1        for i in range(n):            if s[i] in t:                heap1.remove(dict[s[i]].popleft())                dict[s[i]].append(i)                heapq.heappush(heap1,i)                if heapq.nlargest(1, heap1)[0]-heapq.nsmallest(1, heap1)[0]+1<temp_min_length:                    temp_i=heapq.nsmallest(1, heap1)[0]                    temp_j=heapq.nlargest(1, heap1)[0]                    temp_min_length=temp_j-temp_i+1        if temp_min_length<=n:            return s[temp_i:temp_j+1]        return """""https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-'substring'-problems可以用一个hash表来计数所有字符出现的次数和一个标记num代表Ｔ总共有多少字符．然后遍历S，并且将当前字符在hash表中计数减一，如果当前字符在hash表中计数是大于０的，说明这个字符是出现在Ｔ中的，将num也减一，代表我们找到了一个（这个num就是总共有多少字符，我们需要这个来标记是不是找完了所有字符，这也是能够在O(1)时间内判断当前窗口是不是覆盖了Ｔ的关键）．这样当总的数量为０的时候我们就找到了一个覆盖Ｔ的子串窗口．这个窗口因为左端可能包含了一些不必要的字符，因此我们需要将窗口的左端向右移动，使其正好包含Ｔ．在窗口左端向右移动的过程中需要将碰到字符在hash表中＋１，如果当前字符在hash表中的计数为０，而且我们又碰到了，说明这个字符是出现在Ｔ中的，因此num要加一本题的时间要求在O(N)