import copyclass Solution:    def hasPath(self, maze, start, destination):        if len(maze) == 0 or len(maze[0]) == 0: return False        n, m = len(maze), len(maze[0])        level, next_level = [], []        level.append(start)        directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]        visited = [[0 for i in range(m)] for j in range(n)]        visited[start[0]][start[1]] = 1        while level or next_level:            while level:                i, j = level.pop()                if i == destination[0] and j == destination[1]:                    return True                for ii, jj in directions:                    temp_i, temp_j = i, j                    while 0<=temp_i+ii<n and 0<=temp_j+jj<m:                        if maze[temp_i+ii][temp_j+jj] == 0:                            temp_i += ii                            temp_j += jj                        else:                            break                    if visited[temp_i][temp_j] == 0:                        visited[temp_i][temp_j] = 1                        next_level.append([temp_i, temp_j])            level = copy.deepcopy(next_level)            next_level = []        return False