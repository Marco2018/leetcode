class Solution:    def bfs(self, beginWord, endWord, wordList):        queue = [beginWord]        visited = set()        while queue:            word = queue.pop(0)            if word == endWord:                break            for i in range(len(word)):                for j in 'abcdefghijklmnopqrstuvwxyz':                    tmp = word[:i] + j + word[i + 1:]                    if tmp in wordList:                        if tmp not in visited:                            queue.append(tmp)                            visited.add(tmp)                        if self.distance[word] + 1 < self.distance[tmp]:                            self.distance[tmp] = self.distance[word] + 1                            self.pathes[tmp] = set([word])                        elif self.distance[word] + 1 == self.distance[tmp]:                            self.pathes[tmp].add(word)        return    def dfs(self, path, word, beginword):        if word == beginword:            self.res.append(path)            return        for word_x in self.pathes[word]:            self.dfs([word_x] + path, word_x, beginword)        return    def findLadders(self, beginWord, endWord, wordList):        self.pathes = {}        self.distance = {}        max_int = 100000000        wordList = set(wordList)        for word in wordList:            self.distance[word] = max_int        self.distance[beginWord] = 1        if beginWord == endWord or endWord not in wordList:            return []        self.bfs(beginWord, endWord, wordList)        if self.distance[endWord] == max_int:            return []        self.res = []        self.dfs([endWord], endWord, beginWord)        return self.res